---
title: "R packaging"
author: "Emy Guilbault and Arthur Rodrigues"
date: "2023-09-26"
output:
  prettydoc::html_pretty:
    theme: hpstr
    highlight: vignette
    number_sections: TRUE

---

```{css, echo=FALSE}
.blackbox {
  padding: 1em;
  background: lightgray;
  color: grey;
  border: 2px solid darkorange;
  border-radius: 10px;
}
.center {
  text-align: center;
}


<style>
r { color: Red }
o { color: Orange }
g { color: Green }
btu { color: darkturquoise }
br { color: brown }
</style>

```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Presentation: Motivation and use (ARTHUR)
  
Here are some questions to ask yourself when you are interested in coding and/or using functions:
  
::: {.center data-latex=""}
$${\color{red}Why? \space what \space do \space you \space need? }$$
      &rarr; If you need to tailor some existing functions, if you are going to use them many times. If you want to save time and have a way to standardize your coding with existing one.
  
  
$${\color{orange}Who \space is \space it \space for?}$$
      &rarr; Are the changes or the created function of any use for other coders or anyone working in similar field?
  
$${\color{gold}Where?}$$ 
      &rarr; do you need a place to share code and make it available. github is an option. CRAN make it more accessible.
  
$${\color{green}How?}$$ 
      &rarr; We are going to dig into the steps of creating a package!
:::

Here we go beyond the agreed knowledge that everyone knows broadly what is a package and how to install new packages: using `install.packages("x")` and then `library(X)`.
  
<br><br><br><br>


  
One of the main principles in good coding practice is 'do not repeat yourself'. There are some options to achieve these goal. One of them is to create a loop, when your task is only to repeat a procedure with different input. Other option is to create a custom function, which allow you to modify predefined places of your code using arguments. 
  
When we are creating a analysis or cleaning data it could be useful to write a function and let it in a separated file. Then, you only need to add a `source()` in your script to load your custom function in the R environment and you are able use it across your script. Using this approach will make your code more readable and tidy, because instead of several lines of code to do a step of your analysis, you now have only few lines of code using your custom function. Moreover, you can use it several times in your script without need to copy and paste your code and change few characters. 
  
Therefore, for a project you are working, you can create as much functions you need, and load it your scripts using the `source()` function. However, if you have created a set of functions that could be useful in other projects or for other people, it could be nice to create an R package. Which could also let your coding more susceptible to errors. 
  
  

## Pros and cons to create a package
Since you have some custom functions, you might wonder if it is a good idea to create a package. 
  
Pros:   
- Easy access to functions that you've created (it is easier to add a `library()` call in your script than a `source()`)  
- Your functions have help pages
- Your functions could be used by others
- Users could give feedback to your function 
  
Cons:  
- Could be time consuming to create and maintain a package
- Users could give feedback to your functions (bugs)


<br><br><br><br>

# Package structure:  (Emy)
## What compose the R package?
  
* DESCRIPTION file: This is the metadata for the package. It contains:
  + Package name
  + Title and description
  + Authors
  + Dependencies (depends, imports, suggests)
  + Licensing
  + Version number
  + Bug report location, and so on
  
* R/ directory for R files that contain your functions
  
* NAMESPACE file which specifies the function that compose your package and what imports functions from other pacages are needed.
  
These are created using:  `usethis::create_package()`
  
* Other optional information such as data etc..
  
   
### DESCRIPTION file:
The Description file is a simple file format called DCF, the Debian control format. It is created using `usethis::create_package("mypackage")`.
For example, we will set up the different fields:

:::{.blackbox data-latex=""}
Package: Gradients

Title: Creates a gradient image and modify it. *only one line*

Version: 0.0.0.9000 *consider carefully the version*

Authors@R: 
    person("Arthur", "Rodrigues", , "arthur.rodrigues@helsinki.fi", role = c("aut", "cre"), comment = c(ORCID = "YOUR-ORCID-ID"))
    person("Emy", "Guilbault", , "Emy.Guilbault@helsinki.fi", role = c("aut", "cre"),
           comment = c(ORCID = "YOUR-ORCID-ID"))

Description: Gradients creates a customized image that display a gradient of values. Other 
functionalities include modifying the gradient direction or steepness as well as mirroring directly the gradient image. *What the package does (one paragraph)*

License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a
    license

Encoding: UTF-8

Roxygen: list(markdown = TRUE)

RoxygenNote: 7.2.3
:::

The last two fields are created automatically when using the `usethis::create_package("mypackage")`.


Other important information can be included such as:  
URL: https://github.com/EmyGlblt/Rpackaging *link to where the package is advertised*  
BugReports: https://github.com/r-lib/devtools/issues *Where to report any issues*  
Imports: spatstat (>= 3.0-6), glue (>= 1.6.2) *Any necessary packages*  
Suggests: lattice (>= 0.20-44) *Useful but not required*   

which you can get with:
+ exact version
`usethis::use_package("spatstat", min_version = "3.0-6")`

+ min version = currently installed version
`usethis::use_package("spatstat", min_version = TRUE)`

Depends: R (>= 4.0.0)




### R/ directory
In the R/ directory, it is good to have a file per function.

Other directories can be include, which contains non compulsory information, such as:
  + data/: usefull to include for demo or testing purposes of the functions.
  + src/: source and header files for compiled code.
  + inst/: for arbitrary additional files that you want to include in your package.
  + tools/: auxiliary files needed during configuration.
  + demo/: for package demos. 
  + exec/: for executable scripts.
  + po/: translations for messages.
  

<br><br><br><br>
### NAMESPACE

The NAMESPACE file plays a key role in defining your package’s namespace, it looks like a R code without actually being one. It is automatically created with `roxygen2` package, using specific tags located in a roxygen comment above each function’s definition in the R/*.R files and is composed of different functions:

:::{.blackbox data-latex=""}
export(): export a function (including S3 and S4 generics).
S3method(): export an S3 method.
importFrom(): import selected object from another namespace (including S4 generics).
import(): import all objects from another package’s namespace.
useDynLib(): registers routines from a DLL (this is specific to packages with compiled code).
:::
Each directive describes an R object, and says whether it’s exported from this package to be used by others, or it’s imported from another package to be used internally.



<br><br><br><br>

## Other documentation
  
A good package needs good documentation, for that purpose we already talked about the description file above. When creating your R file code it is necessary to inform on the different element in your function which would appear above your code. 

It is helpful to use the *roxygen2* package to manually adapt the documentation files. 
Roxygen comment lines always start with #'. and all the roxygen2 comments preceding a function are collectively called a block.  


Blocks are broken up by tags, which look like @tagName tagValue. A block can contain text before the first tag which is called the introduction. By default, each block generates a single documentation topic, i.e. a single .Rd file in the man/ directory.
Some common tag include: @params, @returns, @description, @seealso, @examples, and @export
  

:::{.blackbox data-latex=""}
#' @params x,y integer values.  
#'  
#' @returns An object of type image.  
#'  
#' @description  
#'  
#' @seealso  
#'   [WiggleImage()] to modify the gradients direction and steepness.  
#'   [TransposeImage] to transpose the image.  
#'  
#' @examples  
#'   Rast2 = CreateGradient(x=-30, y=80)  
#'   plot(Rast2)  
:::

Another important document is the vignette that can be created using: `usethis::use_vignette("my-vignette")`. The vignette is more informative of the workflow and the purpose of your functions.

The first few lines of the vignette contain important metadata. The default template contains the following information:
:::{.blackbox data-latex=""}
title: "Vignette Title" *title that will appear on the vignette*
output: rmarkdown::html_vignette *output format*
vignette: >   *Needed in R*
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
:::

You also have Rmardown chunks to specify:
+ the code output display
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The second chunk just attaches the package the vignette belongs to.
```{r setup}
library(yourpackage)
```

Then, the document is created like a normal Rmarkdown document.


## R code :   
Let's consider few function for raster and image modification. First, our new functions and worflow will depend on other packages that we need to load:
```{r, message=FALSE, warning=FALSE}
library(spatstat)
library(glue)
```

Next, we want to create an image that display a gradient along the area of interest. Thus set the coordinates of our gridded area (resolution) and define a function which will evaluate the values $v1$ across our space. The last step is to create the image using `as.im()`.

```{r, message=FALSE, warning=FALSE}
set.seed(113)
XY = expand.grid(seq(0, 100, 1), seq(0, 100, 1))
X = XY[,1]
Y = XY[,2]

v1 = (X - 30)^2 + (Y + 80)^2 - 0.5*X*Y
v1 = -1*scale(v1)

raster.im = as.im(data.frame(x = X, y = Y, z = v1))
plot(raster.im)

```


These different steps can be combined in a function, where we can play with $n_col$ and $n_row$ to establish a random gradient within space of different sizes. Let's call this function `RandomGradient`
```{r, message=FALSE, warning=FALSE}
### create image/raster

RandomGradient <- function(n_col, n_row, plot = TRUE){
  
  #create the image matrix
  XY = expand.grid(seq(0, n_col-1, 1), seq(0, n_row-1, 1))
  X = XY[,1]
  Y = XY[,2]
  
  # randomize a gradient function
  math_op <- c("-", "+")
  exp_size <- c("^1", "^2", "^3")
  
  op_1 <- sample(math_op, 1)
  op_2 <- sample(math_op, 1)
  op_3 <- sample(math_op, 1)
  op_4 <- sample(math_op, 1)
  
  exp_x <- sample(exp_size, 1)
  exp_y <- sample(exp_size, 1)
  
  val_1 <- sample(seq(0, 100, 1), 1)
  val_2 <- sample(seq(0, 100, 1), 1)
  val_3 <- sample(seq(0, 1, 0.01), 1)
  
  # set the gradient function
  str_expression <-  glue(
    "(X{exp_x} {op_1} {val_1}) {op_2} (Y{exp_y} {op_3} {val_2}) {op_4} ({val_3}*X*Y)"
  )
  
  # Create the raster image 
  v1 <- eval(parse(text = str_expression))
  v1 = scale(v1)
  
  raster.im = as.im(data.frame(x = X, y = Y, z = v1))
  
  if(plot) plot(raster.im, main = "RandomGradient")
  
  raster.im
  return(raster.im)
}

Grad1 = RandomGradient(n_col=20, n_row=40)
```

If we change the value of $n_col$ and $n_row$:
```{r, message=FALSE, warning=FALSE}
Grad2 = RandomGradient(n_col=40, n_row=40)
```

However, we could also want to change the gradient based on the same initial image. For example, we can create a function able to transpose the image we see according to an horizontal or a vertical axis. Let's call this function `TransposeImage`:
```{r, message=FALSE, warning=FALSE}
MirrorImage = function(Rast, direction = c("horizontal", "vertical"),  
                       plot = TRUE){
  
  if(direction == "horizontal"){
    mat1 <- apply(Rast$v, 2, rev)
    m_raster = as.im(t(mat1))
    
  }
  
  if(direction == "vertical"){
    mat1 <- apply(Rast$v, 1, rev)
    m_raster = as.im(t(mat1))
  }
 
  if(plot){
    par(mfrow=c(1,2))
    plot(Rast, main = "Original")
    plot(m_raster, main = "MirrorImage")
  }
  
  m_raster
  return(m_raster)
}

Grad2.hz = MirrorImage(Grad2, direction = "horizontal")

Grad2.vt = MirrorImage(Grad2, direction = "vertical")
```

Finally, we can create a function that modifies the direction of the gradient by playing with $x$ and $y$ or the strength of the gradient with $z$ in the input values in the function `WiggleImage`:
```{r, message=FALSE, warning=FALSE}
WiggleImage = function(Rast, x=NULL, y=NULL, z=NULL, plot = TRUE){
  Grad.w = Rast
  
  if(!is.null(x)){
    X = Grad.w$xcol
    Grad.w$v = Grad.w$v + x*X
  }
  
  if(!is.null(y)){
    Y = Grad.w$yrow
    Grad.w$v = Grad.w$v + x*X + y*Y
  }
  
   if(!is.null(z)){
    X = Grad.w$xcol
    Y = Grad.w$yrow
    
    Grad.w$v = Grad.w$v + z*X*Y
  }
  
  if(plot){
    par(mfrow=c(1,2))
    plot(Rast, main = "Original")
    plot(Grad.w, main = "wiggle")
  }
  return(Grad.w)
}

Rast_change = WiggleImage(Grad2, x = -1, y = 0.6)

Rast_change2 = WiggleImage(Grad2, z = -5)
```

or we can just add general noise overall:
```{r, message=FALSE, warning=FALSE}
AddNoise <- function(Rast, noise = 0.1, plot = TRUE){
  l_vec <- length(Rast$v)
  add_noise <- rnorm(l_vec, 0, noise)
  
  Rast$v <- Rast$v + add_noise
  
  if(plot){
    par(mfrow=c(1,2))
    plot(Rast, main = "Original")
    plot(Rast, main = "AddNoise")
  }
  Rast
  return(Rast)
}

Rast_noise = AddNoise(Grad2, noise = 0.05)
```
Now, we have 4 functions to create our package! Let's call it `Gradients`.
The function created can be organize into one or multiple files if needed.



<br><br><br><br>  

# Creation and Maintenance (Arthur)

Main packages needed for package development:
* devtools: Creation - building o the package
* usethis: help with documentation, testing and broadcast
* roxygen2: help with the documentation set up
* pkgdown:
* testthat: testing

! You also need a system builder ! Make sure Rtools is installed which is done differently depending on your system (windows, MacOS, Linux).

FOR ARTHUR: should we explain this different concept:
```{r pressure, echo=FALSE, fig.cap="A caption", out.width = '100%'}
knitr::include_graphics("install-load.png")
```


<br><br><br><br>

## Step by step
Whole R package development workflow:

* `available::available("pkgname")` # check if package name is available (if planning to publish publicly)
* `usethis::create_package("pkgname")` # create the package
* `usethis::use_git()` # set up version control
* `usethis::use_github()` # optional
* `usethis::use_r("myfile")` # creating new R file in the R/ directory
* `usethis::use_data_raw()` # if adding data
* `devtools::load_all()` # try it out in the console
* `usethis::use_package("import-pkgname")` # add package to import (or depends or suggests)

Documentations:

* `usethis::use_package_doc()` # add package documentation
* `usethis::use_pipe()` # if you want to add %>% from `magrittr`
* `usethis::use_vignette("vignette-name")` # add vignette
* `usethis::use_test()` # make test file for active R file

Write some test

* `devtools::test_active_file()` # test active file
* `devtools::test()` # test whole package
* `devtools::build()` # build vignettes
* `devtools::install()` # to install package
* `devtools::check()` # to build and check a package 
* `usethis::use_readme_rmd()` # to add a README Rmd file
* `styler::style_pkg()` # optional (commit first, then review changes carefully)
* `usethis::use_pkgdown_github_pages()` # for setting up pkgdown website on github
* `usethis::use_pkgdown()` if not using github pages


## Bugs and recommendations


<br><br><br><br>
# Summary of resources

https://r-pkgs.org/description.html

https://rpubs.com/emitanaka/rladies-lagos-paris-2023

https://github.com/EmyGlblt/Rpackaging
